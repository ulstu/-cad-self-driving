# Прошивка радиомодуля сенсорной сети

Открытая библиотека по модулированию и организации работы сенсорной сети с подвижными элементами состоит из двух основных блоков, позволяющих выполнять  имитацию беспроводной среды передачи и формировать протокола самоорганизующейся беспроводной сенсорной сети.

Имитатор беспроводной среды передачи обеспечивает доставку сообщений до беспроводных узлов, находящихся в заданном радиусе действия передатчика, а также обнаружение коллизий.
Протокол самоорганизующейся беспроводной сенсорной сети реализован в виде отдельного класса, что позволяет создавать множество независимых беспроводных узлов, работающих автономно в рамках общей беспроводной сенсорной сети.

Имитатор беспроводной среды передачи реализован в виде библиотеки areaRF.o, которая работает по двухтактной схеме, на первом такте осуществляется: 
* прием сообщений от активных беспроводных узлов; 
* обнаружение беспроводных узлов, попадающих в радиус действия всех принятых сообщений;
* обнаружение беспроводных узлов, попадающих в радиус одновременного  действия двух или более принятых сообщений, т.е. обнаружение коллизий.

На втором такте осуществляется передача сообщений на беспроводные узлы, находящиеся в радиусе действия и для которых отсутствуют коллизии. 

Протокол самоорганизующейся беспроводной сенсорной сети реализован в виде библиотеки protocol.o. Протокол на каждом беспроводном узле работает автономно и требует лишь уникального адреса беспроводного узла. 

Для реализации процедуры моделирования работы выше обозначенных программных модулей в описание каждого беспроводного узла требуется добавить описание его положения. В настоящее время используется двумерная система координат, которая может быть расширена и на трехмерное пространство.

1.2. Описание библиотеки areaRF.o
1.2.1. Подключение библиотеки в среде программирования Python
areaRF = ctypes.CDLL('./objs/areaRF.o')
1.2.2. Размещение беспроводных узлов (принимает аргумент void * (netInit *))
areaRF.NewPlacementInit.argtypes = [ctypes.c_void_p]
Используется структура 
```C
class netInit(ctypes.Structure):
_fields_ = [('MyNumber', ctypes.c_uint8),
        ('Xcoo', ctypes.c_uint8),
        ('Ycoo', ctypes.c_uint8),
        ('NunmberOfDevices', ctypes.c_uint8),
        ('DistanceLimit', ctypes.c_uint16),
        ('CounterRepeat', ctypes.c_uint8)]
```
где MyNumber, Xcoo и Ycoo – номер беспроводного узла, и его начальные координаты соответственно, NunmberOfDevices – количество беспроводных узлов в сенсорной сети, DistanceLimit – максимальная дальность связи, CounterRepeat – резерв. 
В результате происходит присвоение номеров беспроводным узлам и размещение заданного количества беспроводных узлов на некоторой территории.

1.2.3. Обработчик входных сообщений в areaRF от беспроводных узлов
areaRF.areaRFrx.argtypes = [ctypes.c_void_p]
Обработчик принимает аргумент void * (peport *)

```C
class peport(ctypes.Structure):
_fields_ = [('len', ctypes.c_uint8),
                  ('Xcoo', ctypes.c_uint8),
                  ('Ycoo', ctypes.c_uint8),
                 ('Source', ctypes.c_uint8),
                 ('packet', ctypes.c_char_p)]
```
где len – длина принятого сообщения, Xcoo, Ycoo и Source – текущие координаты и номер беспроводного узла соответственно, packet – передаваемое сообщение.

В результата обеспечивается прием и сохранение в буфере всех сообщений, переданных беспроводными узлами в текущий такт имитации работы сенсорной сети.

1.2.4. Инициализация второго такта. Результат возвращается в виде списка всех сообщений, доступных на втором такте работы имитатор беспроводной среды. Сообщения, содержат признак наличия/отсутствия коллизии. Результат возвращается в виде списка в формате uint8 *.
```C
areaRF.Timer_trigger.restype = ctypes.c_char_p
```

В списке помечаются сообщения, которые не могут быть приняты в данной точке приема.

1.2.5. Вычитывание всех сообщений, доступных данному беспроводному узлу с учетом его дальности до передающего беспроводного узла и отсутствия коллизий. Результат возвращается в формате peport *.
areaRF.areaRFtx.restype = ctypes.POINTER(peport)
    В результате конкретный беспроводной узел получает только те сообщения, которые не подвержены коллизии и которые имеют допустимую мощность приема.

1.3. Описание библиотеки protocol.o
1.3.1. Подключение библиотеки в среде программирования Python
```python
protocol = ctypes.CDLL('./objs/protocol.o')
```

# Примеры новых вариантов использования кода
Разработанный код может применяться в рамках:
1. Обмена данными между элементами в технологии «Умный дом», «Умный город» и т.д.
2. Сбора информации с распределенных по территории стационарных датчиков (датчики слежения за пожаром в труднодоступной местности, датчики качества работы протяженных объектов, трубопроводов, датчики мониторинга параметров окружающей среды, почвы).
3. Обмена данными между подвижными объектами, выполняющими специальные задачи в рамках единой группы.

В файле [protocol_2.c](protocol_2.c) представлен фрагмент кода, позволяющего производить  взаимодействие между радиоустройствами с помощью разработанной открытой библиотеки для решения описанных выше задач. 